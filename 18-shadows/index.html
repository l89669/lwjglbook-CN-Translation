<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Mouse0w0">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>阴影（Shadows） - Lwjglbook中文翻译</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u9634\u5f71\uff08Shadows\uff09";
    var mkdocs_page_input_path = "18-shadows.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Lwjglbook中文翻译</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../01-first-steps/">事前准备（First Steps）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../02-the-game-loop/">游戏循环（The Game Loop）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../03-a-brief-about-coordinates/">坐标简介（A brief about coordinates）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../04-rendering/">渲染（Rendering）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../05-more-on-rendering/">更多关于渲染的事情（More on Rendering）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../06-transformations/">变换（Transformations）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../07-textures/">纹理（Textures）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../08-camera/">摄像机（Camera）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../09-loading-more-complex-models/">加载更复杂的模型（Loading more complex models）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../10-let-there-be-light/">要有光（Let there be light）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../11-let-there-be-even-more-light/">要有更多的光（Let there be even more light）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../12-game-hud/">游戏HUD（Game HUD）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../13-sky-box-and-some-optimizations/">天空盒与一些优化 (Sky Box and some optimizations)</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../14-height-maps/">高度图（Height Maps）</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../15-terrain-collisions/">地形碰撞 (Terrain Collisions)</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../16-fog/">雾 (Fog)</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../17-normal-mapping/">法线贴图（Normal Mapping）</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Lwjglbook中文翻译</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>阴影（Shadows）</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/Mouse0w0/lwjglbook-CN-Translation/edit/master/docs/18-shadows.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="shadows">阴影（Shadows）</h1>
<h2 id="shadow-mapping">Shadow Mapping</h2>
<p>Currently we are able to represent how light affects the objects in a 3D scene. Objects that get more light are shown brighter then objects that do not receive light. However we are still not able to cast shadows. Shadows will increase the degree of realism that 3D scene would have so we will add support for it in this chapter.</p>
<p>We will use a technique named Shadow mapping which is widely used in games and does not affect severely the engine performance.  Shadow mapping may seem simple to understand but it’s somehow difficult to implement it right. Or, to be more precise, it’s very difficult to implement it in a generic ways that cover all the potential cases and produces consistent results.</p>
<p>We will explain here an approach which will serve you to add shadows for most of the cases, but what it’s more important it will serve you to understand its limitations. The code presented here is far from being perfect but I think it will be easy to understand. It is also designed to support directional lights <script type="math/tex">which in my opinion is the more complex case</script> but you will learn how it can be extended to support other type of lights <script type="math/tex">such us point lights</script>. If you want to achieve more advanced results you should use more advance techniques such as Cascaded Shadow Maps. In any case the concepts explained here will serve you as a basis.</p>
<p>So let’s start by thinking in how we could check if a specific area <script type="math/tex">indeed a fragment</script> is in shadow or not. While drawing  that area if we can cast rays to the light source, if we can reach the light source without any collision then that pixel is in light. If not, then the pixel is in shadow.</p>
<p>The following picture shows the case for a point light, the point PA can reach the source light, but points PB and PC can’t so they are in shadow.</p>
<p><img alt="Shadow Concepts I" src="../_static/18/shadow_concepts_I.png" /></p>
<p>So, how we can check if we can cast that ray without collisions in an efficient manner?  A light source can, theoretically cast infinitely ray lights, so how do we check if a ray light is blocked or not ? <br />
What we can do instead of casting ray lights is to look at the 3D scene from the light’s persèctive and render the scene from that location. We can set the camera at the light position and render the scene so we can store the depth for each fragment. This is equivalent to calculate the distance of each fragment to the light source. At the end, what we are doing is storing the minimum distance as seen from the light source  as a shadow map.</p>
<p>The following picture shows a cube floating over a plane and  a perpendicular light.</p>
<p><img alt="Shadow Concepts II" src="../_static/18/shadow_concepts_II.png" /></p>
<p>The scene as seen from the light perspective would be something like this <script type="math/tex">the darker the colour, the closer to the light source</script>.</p>
<p><img alt="Rendering from light perspective" src="../_static/18/render_light_perspective.png" /></p>
<p>With that information  we can render the 3D scene as usual and check the distance for each fragment to the light source with the minimum stored distance. If the distance is less that the value stored in the shadow map, then the object is in light, otherwise is in shadow. We can have several objects that could be hit by the same ray light. But we store the minimum distance.</p>
<p>Thus, shadow mapping is a two step process:</p>
<ul>
<li>First we render the scene from the light space into a shadow map to get the minimum distances.</li>
<li>Second we render the scene from the camera point of view and use that depth  map to calculate if objects are in shadow or not.</li>
</ul>
<p>In order to render the depth map we need to talk about the depth buffer. When we render a scene all the depth information is stored in a buffer named, obviously, depth-buffer <script type="math/tex">also z-buffer</script>. That depth information is the <script type="math/tex; mode=display">z</script> value of each of the fragment that is rendered. If you recall from the first chapters what we are doing while rendering a scene is transforming from world coordinates to screen coordinates. We are drawing to a coordinate space which ranges from <script type="math/tex; mode=display">0</script> to <script type="math/tex; mode=display">1</script> for <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">y</script> axis. If an object is more distant than other, we must calculate how this affects their <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">y</script> coordinates through the perspective projection matrix. This is not calculated automatically depending on the <script type="math/tex; mode=display">z</script> value, this must be done us. What is actually stored in the z coordinate its the depth of that fragment, nothing less but nothing more.</p>
<p>Besides that, in our source code we are enabling depth testing. In the Window class we have set the following line:</p>
<pre><code class="glsl">glEnable(GL_DEPTH_TEST);
</code></pre>

<p>By setting this line we prevent fragments that cannot be seen, because they are behind other objects, to be drawn. Before a fragment is drawn its <script type="math/tex; mode=display">z</script> value is compared with the <script type="math/tex; mode=display">z</script> value of the z-buffer. If it has a higher <script type="math/tex; mode=display">z</script> value <script type="math/tex">it’s far away</script> than the <script type="math/tex; mode=display">z</script> value of the buffer it’s discarded. Remember that this is done in screen space, so we are comparing the <script type="math/tex; mode=display">z</script> value of a fragment given a pair of <script type="math/tex; mode=display">x</script> and <script type="math/tex; mode=display">y</script> coordinates in screen space, that is in the range <script type="math/tex; mode=display">[0, 1]</script>. Thus, the <script type="math/tex; mode=display">z</script> value is also in that range.<br />
The presence of the depth buffer is the reason why we need to clear the screen before performing any render operation. We need to clear not only the colour but the depth information also:</p>
<pre><code class="java">public void clear() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}
</code></pre>

<p>In order to start building the depth map we want to get that depth information as viewed from the light perspective. We need to setup a camera in the light position, render the scene and store that depth information into a texture so we can access to it later.</p>
<p>Therefore, the first thing we need to do is add support for creating those textures.  We will modify the <code>Texture</code> class to support the creation of empty textures by adding a new constructor. This constructor expects the dimensions of the texture and the format of the pixels it stores.</p>
<pre><code class="java">public Texture(int width, int height, int pixelFormat) throws Exception {
    this.id = glGenTextures();
    this.width = width;
    this.height = height;
    glBindTexture(GL_TEXTURE_2D, this.id);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, this.width, this.height, 0, pixelFormat, GL_FLOAT, (ByteBuffer) null);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
}
</code></pre>

<p>We set the texture wrapping mode to <code>GL_CLAMP_TO_EDGE</code> since we do not want the texture to repeat in case we exceed the <script type="math/tex; mode=display">[0, 1]</script> range.</p>
<p>So now that we are able to create empty textures, we need to be able to render a scene into it. In order to do that we need to use Frame Buffers Objects <script type="math/tex">or FBOs</script>. A Frame Buffer is a collection of buffers that can be used as a destination for rendering. When we have been rendering to the screen we have using OpenGL’s default buffer. OpenGL allows us to render to user defined buffers by using FBOs. We will isolate the rest of the code of the process of creating FBOs for shadow mapping by creating a new class named <code>ShadowMap</code>. This is the definition of that class.</p>
<pre><code class="java">package org.lwjglb.engine.graph;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL30.*;

public class ShadowMap {

    public static final int SHADOW_MAP_WIDTH = 1024;

    public static final int SHADOW_MAP_HEIGHT = 1024;

    private final int depthMapFBO;

    private final Texture depthMap;

    public ShadowMap() throws Exception {
        // Create a FBO to render the depth map
        depthMapFBO = glGenFramebuffers();

        // Create the depth map texture
        depthMap = new Texture(SHADOW_MAP_WIDTH, SHADOW_MAP_HEIGHT, GL_DEPTH_COMPONENT);

        // Attach the the depth map texture to the FBO
        glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap.getId(), 0);
        // Set only depth
        glDrawBuffer(GL_NONE);
        glReadBuffer(GL_NONE);

        if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
            throw new Exception(&quot;Could not create FrameBuffer&quot;);
        }

        // Unbind
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
    }

    public Texture getDepthMapTexture() {
        return depthMap;
    }

    public int getDepthMapFBO() {
        return depthMapFBO;
    }

    public void cleanup() {
        glDeleteFramebuffers(depthMapFBO);
        depthMap.cleanup();
    }
}
</code></pre>

<p>The <code>ShadowMap</code> class defines two constants that determine the size of the texture that will  hold the depth map. It also defines two attributes, one for the FBO and one for the texture. In the constructor, we create a new FBO and a new <code>Texture</code>. For the FBO we will use as the pixel format the constant <code>GL_DEPTH_COMPONENT</code> since we are only interested in storing depth values. Then we attach the FBO to the texture instance.</p>
<p>The following lines explicitly set the FBO to not render any colour. A FBO needs a colour buffer, but we are not going to needed. This is why we set the colour buffers to be used as <code>GL_NONE</code>.</p>
<pre><code class="java">glDrawBuffer(GL_NONE);
glReadBuffer(GL_NONE);
</code></pre>

<p>Now we are ready to render the scene from the light perspective into FBO in the <code>Renderer</code> class. In order to do that, we will create a specific set of vertex and fragments shaders.</p>
<p>The vertex shader, named <code>depth_vertex.fs</code>, is defined like this.</p>
<pre><code class="glsl">#version 330

layout (location=0) in vec3 position;
layout (location=1) in vec2 texCoord;
layout (location=2) in vec3 vertexNormal;

uniform mat4 modelLightViewMatrix;
uniform mat4 orthoProjectionMatrix;

void main()
{
    gl_Position = orthoProjectionMatrix * modelLightViewMatrix * vec4(position, 1.0f);
}
</code></pre>

<p>We expect to receive the same input data as the scene shader. In fact, we only need the position, but to reuse as much as code as possible we will pass it anyway. We also need a pair of matrices. Remember that we must render the scene from the light point of view, so we need to transform our models to light's coordinate space. This is done through the <code>modelLightViewMatrix</code> matrix, which is analogous to view model matrix used for a camera. The light is our camera now.</p>
<p>Then we need to transform those coordinates to screen space, that is, we need to project them. And this is one of the differences while calculating shadow maps for directional lights versus point lights. For point lights we would use a perspective projection matrix as if we were rendering the scene normally. Directional lights, instead, affect all objects in the same way independently of the distance. Directional lights are located at an infinite point and do not have a position but a direction. An orthographic projection does not render distant objects smaller, and because of this characteristic is the most suitable for directional lights.</p>
<p>The fragment shader is even simpler. It just outputs the <script type="math/tex; mode=display">z</script> coordinate as the depth value.</p>
<pre><code class="glsl">#version 330

void main()
{
    gl_FragDepth = gl_FragCoord.z;
}
</code></pre>

<p>In fact, you can remove that line, since we are only generating depth values, the depth value it will be automatically returned.</p>
<p>Once we have defined the new shaders for depth rendering we can use them in the <code>Renderer</code> class. We define a new method for setting up those shaders, named <code>setupDepthShader</code>, which will be invoked where the others shaders are initialized.</p>
<pre><code class="java">private void setupDepthShader() throws Exception {
    depthShaderProgram = new ShaderProgram();
    depthShaderProgram.createVertexShader(Utils.loadResource(&quot;/shaders/depth_vertex.vs&quot;));
    depthShaderProgram.createFragmentShader(Utils.loadResource(&quot;/shaders/depth_fragment.fs&quot;));
    depthShaderProgram.link();

    depthShaderProgram.createUniform(&quot;orthoProjectionMatrix&quot;);
    depthShaderProgram.createUniform(&quot;modelLightViewMatrix&quot;);
}
</code></pre>

<p>Now we need to create a new method that uses those shaders which will be named <code>renderDepthMap</code>. This method will be invoked in the principal render method.</p>
<pre><code class="java">public void render(Window window, Camera camera, Scene scene, IHud hud) {
    clear();

    // Render depth map before view ports has been set up
    renderDepthMap(window, camera, scene);

    glViewport(0, 0, window.getWidth(), window.getHeight());

    // Rest of the code here ....
</code></pre>

<p>If you look at the above code you will see that the new method is invoked at the very beginning, before we have set the view port. This is due to the fact that this new method will change the view port to match the dimensions of the texture that holds the depth map. Because of that, we will always need to set, after the <code>renderDepthMap</code> has been finished, the view port to the screen dimensions <script type="math/tex">without checking if the window has been resized</script>.</p>
<p>Let’s define now the <code>renderDepthMap</code> method. The first thing that we will do is to bind to the FBO we have created in the <code>ShadowMap</code> class and set the view port to match the texture dimensions.</p>
<pre><code class="java">glBindFramebuffer(GL_FRAMEBUFFER, shadowMap.getDepthMapFBO());
glViewport(0, 0, ShadowMap.SHADOW_MAP_WIDTH, ShadowMap.SHADOW_MAP_HEIGHT);
</code></pre>

<p>Then we clear the depth buffer contents and bind the depth shaders. Since we are only dealing with depth values we do not need to clear colour information.</p>
<pre><code class="java">glClear(GL_DEPTH_BUFFER_BIT);

depthShaderProgram.bind();
</code></pre>

<p>Now we need to setup the matrices, and here comes the tricky part. We use the light as a camera so we need to create a view matrix which needs a position and three angles. As it has been said at the beginning of the chapter we will support  only directional lights, and that type of lights does not define a position but a direction. If we were using point lights this would be easy, the position of the light would be the position of the view matrix, but we do not have that.</p>
<p>We will take a simple approach to calculate the light position. Directional lights are defined by a vector, usually, normalized, which points to the direction where the light is. We will multiply that direction vector by a configurable factor so it defines a point at a reasonable distance for the scene we want to draw. We will use that direction in order to calculate the rotation angle for that view matrix.</p>
<p><img alt="Light position" src="../_static/18/light_position.png" /></p>
<p>This is the fragment that calculates the light position and the rotation angles</p>
<pre><code class="java">float lightAngleX = (float)Math.toDegrees(Math.acos(lightDirection.z));
float lightAngleY = (float)Math.toDegrees(Math.asin(lightDirection.x));
float lightAngleZ = 0;
Matrix4f lightViewMatrix = transformation.updateLightViewMatrix(new Vector3f(lightDirection).mul(light.getShadowPosMult()), new Vector3f(lightAngleX, lightAngleY, lightAngleZ));
</code></pre>

<p>Next we need to calculate the orthographic projection matrix.</p>
<pre><code class="java">Matrix4f orthoProjMatrix = transformation.updateOrthoProjectionMatrix(orthCoords.left, orthCoords.right, orthCoords.bottom, orthCoords.top, orthCoords.near, orthCoords.far);
</code></pre>

<p>We have modified the <code>Transformation</code> class to include the light view matrix and the orthographic projection matrix. Previously we had a orthographic 2D projection matrix, so we have renamed the previous methods and attributes. You can check the definition in the source code which is straight forward.</p>
<p>Then we render the scene  objects as in the <code>renderScene</code> method but using the previous matrices to work in light space coordinate system.</p>
<pre><code class="java">depthShaderProgram.setUniform(&quot;orthoProjectionMatrix&quot;, orthoProjMatrix);
Map&lt;Mesh, List&lt;GameItem&gt;&gt; mapMeshes = scene.getGameMeshes();
for (Mesh mesh : mapMeshes.keySet()) {
    mesh.renderList(mapMeshes.get(mesh), (GameItem gameItem) -&gt; {
        Matrix4f modelLightViewMatrix = transformation.buildModelViewMatrix(gameItem, lightViewMatrix);
        depthShaderProgram.setUniform(&quot;modelLightViewMatrix&quot;, modelLightViewMatrix);
    }
    );
}

// Unbind
depthShaderProgram.unbind();
glBindFramebuffer(GL_FRAMEBUFFER, 0);
</code></pre>

<p>The parameterization of the orthographic projection matrix is defined in the directional Light. Think of the orthographic projection matrix as a bounding box that contains all the objects that we want to render. When projecting only the objects that fit into that bounding box will be be visible. That bounding box is defined by 6  parameters:  left, right, bottom, top, near, far. Since, the light position is now the origin, these parameters define the distance from that origin to the left or right <script type="math/tex">x-axis</script> up or down <script type="math/tex">y-axis</script> and to the nearest or farthest plane <script type="math/tex">z-axis</script>.</p>
<p>One of the trickiest points in  getting shadows map to work is determine the light position and the orthographic projection matrix parameters. This is way all these parameters are now defined in the <code>DirectionalLight</code> class so it can be set properly according to each scene.</p>
<p>You can implement a more automatic approach, by calculating the centre of the camera frustum, get back in the light direction and build a orthographic projection that contains all the objects in the scene.  The following figure shows a 3D scene as looked form above, the camera position and its frustum <script type="math/tex">in blue</script> and the optimal light position and bounding box in red.</p>
<p><img alt="Generic Light position calculation" src="../_static/18/generic_light_pos_calculation.png" /></p>
<p>The problem with the approach above is that is difficult to calculate and if you have small objects and the bounding box is big you may get strange results. The approach presented here is simpler for small scenes and you can tweak it to match your models <script type="math/tex">even you can chose to explicitly set light’s position to avoid strange effects if camera moves far away from the origin</script>. If you want a more generic model that can be applied to any scene you should extend it to support cascading shadow maps.</p>
<p>Let's continue. Before we use the depth maps to actually calculate shadows, you could render a quad with the generated texture to see how  a real depth map looks like. You could get something like this for a scene composed by a rotating cube floating over a plane with a perpendicular directional light.</p>
<p><img alt="Depth map" src="../_static/18/depth_map.png" /></p>
<p>As it's been said before, the darker the colour, the closer to the light position. What’s the effect of the light position in the depth map? You can play with the multiplication factor of the directional light and you will see that the size of the objects rendered in the texture do not decrease. Remember that we are using an orthographic projection matrix and objects do not get smaller with distance. What you will see is that all colours get brighter as seen in the next picture.</p>
<p><img alt="Depth map at a higher distance" src="../_static/18/depth_map_higher_distance.png" /><br />
Does that mean that we can choose a high distance for the light position without consequences? The answer is no. If light is too far away from the objects we want to render, these objects can be out of the bounding box that defines the orthographic projection matrix. In this case you will get a nice white texture which would be useless for shadow mapping. Ok, then we simply increase the bounding box size and everything will be ok, right? The answer is again no. If you chose huge dimensions for the orthographic projection matrix your objects will be drawn very small in the texture, and the depth values can even overlap leading to strange results.  Ok, so you can think in increasing the texture size, but, again in this case you are limited and textures cannot grow indefinitely to use huge bounding boxes.</p>
<p>So as you can see selecting the light position and the orthographic projection parameters is a complex equilibrium which makes difficult to get right results using shadow mapping.</p>
<p>Let’s go back to the rendering process, once we have calculated the depth map we can use it while rendering the scene. First we need to modify the scene vertex shader. Up to now, the vertex shader  projected the vertex coordinates from model view space to the screen space using a perspective matrix. Now we need to project also the vertex coordinates from light space coordinates using a projection matrix to be used in the fragment shader to calculate the shadows.</p>
<p>The vertex shader is modified like this.</p>
<pre><code class="glsl">#version 330

layout (location=0) in vec3 position;
layout (location=1) in vec2 texCoord;
layout (location=2) in vec3 vertexNormal;

out vec2 outTexCoord;
out vec3 mvVertexNormal;
out vec3 mvVertexPos;
out vec4 mlightviewVertexPos;
out mat4 outModelViewMatrix;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 modelLightViewMatrix;
uniform mat4 orthoProjectionMatrix;

void main()
{
    vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * mvPos;
    outTexCoord = texCoord;
    mvVertexNormal = normalize(modelViewMatrix * vec4(vertexNormal, 0.0)).xyz;
    mvVertexPos = mvPos.xyz;
    mlightviewVertexPos = orthoProjectionMatrix * modelLightViewMatrix * vec4(position, 1.0);
    outModelViewMatrix = modelViewMatrix;
}
</code></pre>

<p>We use new uniforms for the light view matrix and the orthographic projection matrix.</p>
<p>In the fragment shader we will create a new function to calculate the shadows that is defined like this.</p>
<pre><code class="glsl">float calcShadow(vec4 position)
{
    float shadowFactor = 1.0;
    vec3 projCoords = position.xyz;
    // Transform from screen coordinates to texture coordinates
    projCoords = projCoords * 0.5 + 0.5;
    if ( projCoords.z &lt; texture(shadowMap, projCoords.xy).r ) 
    {
        // Current fragment is not in shade
        shadowFactor = 0;
    }

    return 1 - shadowFactor;
}
</code></pre>

<p>The function receives the position in light view space projected using the orthographic projection matrix. It returns <script type="math/tex; mode=display">0</script> if the position is in shadow and <script type="math/tex; mode=display">1</script> if it’s not. First, the coordinates are transformed to texture coordinates. Screen coordinates are in the range <script type="math/tex; mode=display">[-1, 1</script>], but texture coordinates are in the range <script type="math/tex; mode=display">[0, 1]</script>. With that coordinates we get the depth value from the texture and compare it with the <script type="math/tex; mode=display">z</script> value of the fragment coordinates. If the <script type="math/tex; mode=display">z</script> value if the fragment has a lower value than the one stored in the texture that means that the fragment is not in shade.</p>
<p>In the fragment shader, the return value from the <code>calcShadow</code> function to modulate the light colour contributions from point, spot and directional lights. The ambient light is not affected by the shadow.</p>
<pre><code class="glsl">float shadow = calcShadow(mlightviewVertexPos);
fragColor = clamp(ambientC * vec4(ambientLight, 1) + diffuseSpecularComp * shadow, 0, 1);
</code></pre>

<p>In the <code>renderScene</code> method of the <code>Renderer</code> class we just need to pass the uniform for the orthographic projection and light view matrices <script type="math/tex">we need to modify also the method that initializes the shader to create the new uniforms</script>. You can consult this in the book’s source code.</p>
<p>If to run the <code>DummyGame</code> class, which has been modified to setup a floating cube over a plane with a directional light which angle can be changed by using up and down keys, you should see something like this.</p>
<p><img alt="Shadow Map result" src="../_static/18/shadow_map_result.png" /></p>
<p>Although shadows are working <script type="math/tex">you can check that by moving light direction</script>, the implementation presents some problems. First of all, there are strange lines in the objects that are lightened up. This effect is called shadow acne, and it’s produced by the limited resolution of the texture that stores the depth map. The second problem is that the borders of the shadow are not smooth and look blocky. The cause is the same again, the texture resolution. We will solve these problems in order to improve shadow quality.</p>
<h2 id="shadow-mapping-improvements">Shadow Mapping improvements</h2>
<p>Now that we have the shadow mapping mechanism working, let’s solve the problems we have. Let’s first start with the shadow acne problem. The depth map texture is limited in size, and because of that, several fragments can be mapped to the same pixel in that texture depth. The texture depth stores the minimum depth, so at the end, we have several fragments that share the same depth in that texture although they are at different distances.</p>
<p>We can solve this by increasing, by a little bit the depth comparison in the fragment shader, we add a bias.</p>
<pre><code class="glsl">float bias = 0.05;
if ( projCoords.z - bias &lt; texture(shadowMap, projCoords.xy).r ) 
{
    // Current fragment is not in shade
    shadowFactor = 0;
}
</code></pre>

<p>Now, the shadow acne has disappeared.</p>
<p><img alt="Shadow without acne" src="../_static/18/shadow_no_acne.png" /></p>
<p>Now we are going to solve de shadow edges problem, which is also caused by the texture resolution. For each fragment we are going to sample the depth texture with the fragment’s position value and the surrounding values. Then we will calculate the average and assign that value as the shadow value. In this case his value won’t be <script type="math/tex; mode=display">0</script> or <script type="math/tex; mode=display">1</script> but can take values in between in order to get smoother edges.</p>
<p><img alt="Depth average value" src="../_static/18/depth_average_value.png" /></p>
<p>The surrounding values must be at one pixel distance of the current fragment position in texture coordinates.  So we need to calculate the increment of one pixel in texture coordinates which is equal to <script type="math/tex; mode=display">1 / textureSize</script>.</p>
<p>In the fragment Shader we just need to modify the shadow factor calculation to get an average value.</p>
<pre><code class="glsl">float shadowFactor = 0.0;
vec2 inc = 1.0 / textureSize(shadowMap, 0);
for(int row = -1; row &lt;= 1; ++row)
{
    for(int col = -1; col &lt;= 1; ++col)
    {
        float textDepth = texture(shadowMap, projCoords.xy + vec2(row, col) * inc).r; 
        shadowFactor += projCoords.z - bias &gt; textDepth ? 1.0 : 0.0;        
    }    
}
shadowFactor /= 9.0;
</code></pre>

<p>The result looks now smoother.</p>
<p><img alt="Final result" src="../_static/18/final_result.png" /></p>
<p>Now our sample looks much better. Nevertheless, the shadow mapping technique presented here can still be improved a lot. You can check about solving peter panning effect <script type="math/tex">caused by the bias factor</script> and other techniques to improve the shadow edges. In any case, with the concepts explained here you have a good basis to start modifying the sample.</p>
<p>In order to render multiple lights you just need to  render a separate depth map for each light source. While rendering the scene you will need to sample all those depth maps to calculate the appropriate shadow factor.</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>2018, Mouse0w0</p>
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Mouse0w0/lwjglbook-CN-Translation/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
